---
globs: *.tsx,*.ts
description: React Hooks best practices and common pitfalls to avoid
---

# React Hooks Best Practices

## üö® Critical Rules of Hooks

### 1. Hooks Order Must Be Consistent
**ALWAYS call hooks at the TOP LEVEL** - never after conditional returns, loops, or nested functions.

```tsx
// ‚ùå WRONG - Hook called after conditional return
function Component() {
  if (someCondition) {
    return <div>Early return</div>
  }
  
  const { data } = useQuery(...) // ‚ùå This violates Rules of Hooks
}

// ‚úÖ CORRECT - All hooks at top level
function Component() {
  const { data } = useQuery(...) // ‚úÖ Hook at top level
  
  if (someCondition) {
    return <div>Early return</div>
  }
}
```

### 2. Avoid Variable Name Conflicts
When using React Query with local state, rename conflicting variables:

```tsx
// ‚ùå WRONG - Variable name conflict
const [isLoading, setIsLoading] = useState(true)
const { isLoading, error } = useQuery(...) // ‚ùå Duplicate 'isLoading'

// ‚úÖ CORRECT - Rename to avoid conflict
const [isLoading, setIsLoading] = useState(true)
const { isLoading: isQueryLoading, error } = useQuery(...)
```

### 3. Authentication Flow Pattern
For authentication components, follow this exact pattern:

```tsx
function ProtectedComponent() {
  // 1. All hooks at top level
  const [user, setUser] = useState<User | null>(null)
  const [isLoadingUser, setIsLoadingUser] = useState(true)
  
  // 2. Server queries (even if disabled)
  const { isLoading: isVerifying, error } = useQuery({
    queryKey: ['currentUser'],
    queryFn: () => apiClient.getCurrentUser(),
    enabled: false, // Can be conditionally enabled later
  })
  
  // 3. Effects for localStorage/initialization
  useEffect(() => {
    // Load user from localStorage
    const storedUser = localStorage.getItem('pos_user')
    if (storedUser) {
      setUser(JSON.parse(storedUser))
    }
    setIsLoadingUser(false)
  }, [])
  
  // 4. Conditional returns AFTER all hooks
  if (isLoadingUser) return <LoadingSpinner />
  if (!user) return <Navigate to="/login" />
  
  return <MainComponent user={user} />
}
```

### 4. Error Prevention Checklist
Before submitting React components:
- [ ] All hooks called at component top level
- [ ] No duplicate variable names from destructuring
- [ ] useEffect has proper dependency array
- [ ] useState initial values match expected types
- [ ] No hooks inside conditions, loops, or nested functions

### 5. Common Hook Patterns

#### Local Storage with State
```tsx
// ‚úÖ CORRECT pattern for localStorage + state
const [user, setUser] = useState<User | null>(null)
const [isLoading, setIsLoading] = useState(true)

useEffect(() => {
  const storedUser = localStorage.getItem('pos_user')
  if (storedUser) {
    try {
      setUser(JSON.parse(storedUser))
    } catch (error) {
      localStorage.removeItem('pos_user')
    }
  }
  setIsLoading(false)
}, [])
```

#### API Queries with Conditional Enabling
```tsx
// ‚úÖ CORRECT - Query declared at top, conditionally enabled
const { data, isLoading: isApiLoading } = useQuery({
  queryKey: ['data'],
  queryFn: fetchData,
  enabled: shouldFetchData && !!user, // Conditional enabling
})
```

## Debugging Hooks Issues
When you see "Rendered more hooks than during the previous render":
1. Check that all hooks are at the component top level
2. Verify no hooks are called conditionally
3. Look for variable name conflicts in destructuring
4. Ensure consistent hook call order across renders