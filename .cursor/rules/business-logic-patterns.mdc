---
description: Comprehensive business logic patterns for POS System domain understanding, user journeys, and workflow optimization
---

# üçΩÔ∏è POS Business Logic & Domain Patterns

## üéØ Core Business Domain Understanding

### Restaurant Operations Model
The POS system orchestrates complex restaurant operations with multiple stakeholders and intricate workflows:

```typescript
// Domain Model - Core Business Entities
interface RestaurantDomain {
  // Revenue Generation
  orders: OrderLifecycle[]
  payments: PaymentProcessing[]
  inventory: InventoryManagement
  
  // Operations Management  
  tables: TableManagement
  staff: StaffOperations
  kitchen: KitchenWorkflow
  
  // Business Intelligence
  analytics: BusinessAnalytics
  reporting: FinancialReporting
}

// Business Rules Engine
class POSBusinessRules {
  validateOrderCreation(order: CreateOrderRequest): ValidationResult
  calculatePricing(items: OrderItem[]): PricingCalculation
  manageInventory(productId: string, quantity: number): InventoryResult
  optimizeKitchenWorkflow(orders: Order[]): WorkflowOptimization
}
```

## üîÑ Critical User Journeys & Performance Optimization

### 1. Server Journey: Dine-In Order Creation (Target: <30 seconds)
```typescript
// ‚úÖ PERFORMANCE-OPTIMIZED: Server workflow
class ServerWorkflowOptimization {
  // Pre-load critical data for instant access
  private async preloadServerData(): Promise<ServerContext> {
    const [products, categories, tables, activeOrders] = await Promise.all([
      this.productService.getAvailableProducts(), // Cache for 5 minutes
      this.categoryService.getActiveCategories(), // Cache for 1 hour  
      this.tableService.getTableStatus(), // Real-time, 30s cache
      this.orderService.getActiveOrders() // Real-time, 10s cache
    ])
    
    return { products, categories, tables, activeOrders }
  }

  // Optimistic order creation with rollback
  async createOrderOptimistic(orderData: CreateOrderRequest): Promise<Order> {
    // 1. Immediate UI feedback (0ms)
    this.ui.showOrderCreating(orderData)
    
    // 2. Validate business rules locally (5-10ms)
    const validation = await this.validateOrderBusiness(orderData)
    if (!validation.isValid) {
      throw new BusinessRuleError(validation.errors)
    }
    
    // 3. Optimistic update (10-15ms)
    const optimisticOrder = this.generateOptimisticOrder(orderData)
    this.ui.showOrderCreated(optimisticOrder)
    
    // 4. Background server sync (100-200ms)
    try {
      const serverOrder = await this.orderService.createOrder(orderData)
      this.reconcileOptimisticOrder(optimisticOrder, serverOrder)
      return serverOrder
    } catch (error) {
      // Rollback optimistic changes
      this.rollbackOptimisticOrder(optimisticOrder)
      throw error
    }
  }

  // Business rule validation (prevent API round-trips)
  private async validateOrderBusiness(order: CreateOrderRequest): Promise<ValidationResult> {
    const errors: string[] = []
    
    // Table availability check
    if (order.table_id && !this.isTableAvailable(order.table_id)) {
      errors.push('Table is not available')
    }
    
    // Product availability batch check
    const unavailableItems = order.items.filter(item => 
      !this.isProductAvailable(item.product_id, item.quantity)
    )
    if (unavailableItems.length > 0) {
      errors.push(`Products unavailable: ${unavailableItems.map(i => i.product_id).join(', ')}`)
    }
    
    // Business hours validation
    if (!this.isDuringBusinessHours()) {
      errors.push('Orders cannot be created outside business hours')
    }
    
    return { isValid: errors.length === 0, errors }
  }
}
```

### 2. Kitchen Journey: Order Processing (Target: <5 seconds per status update)
```typescript
// ‚úÖ REAL-TIME OPTIMIZED: Kitchen workflow with WebSocket-like updates
class KitchenWorkflowEngine {
  private orderPriorityQueue: PriorityQueue<KitchenOrder>
  private preparationTimers: Map<string, Timer>
  private realTimeUpdates: EventEmitter

  // Intelligent order prioritization
  async optimizeKitchenQueue(): Promise<KitchenOrder[]> {
    const activeOrders = await this.getActiveKitchenOrders()
    
    // Business logic: Priority calculation
    return activeOrders
      .map(order => ({
        ...order,
        priority: this.calculateOrderPriority(order),
        estimatedTime: this.estimatePreparationTime(order),
        dependencies: this.findOrderDependencies(order)
      }))
      .sort((a, b) => {
        // Priority factors: wait time, complexity, table status, special requests
        return (b.priority * b.waitTime * b.tableUrgency) - (a.priority * a.waitTime * a.tableUrgency)
      })
  }

  // Real-time status updates with business impact
  async updateOrderStatus(orderId: string, status: KitchenStatus): Promise<void> {
    const order = await this.getOrder(orderId)
    const businessImpact = await this.calculateBusinessImpact(order, status)
    
    // Update with business context
    await this.orderService.updateOrderStatus(orderId, {
      status,
      estimated_completion: businessImpact.estimatedCompletion,
      kitchen_notes: businessImpact.notes,
      affects_other_orders: businessImpact.dependencies
    })
    
    // Trigger real-time notifications
    this.notifyStakeholders(order, status, businessImpact)
    
    // Update kitchen display optimization
    this.reoptimizeKitchenQueue()
  }

  // Business intelligence: Kitchen performance metrics
  private calculateBusinessImpact(order: Order, newStatus: KitchenStatus): BusinessImpact {
    return {
      tableWaitTime: this.calculateTableWaitTime(order.table_id),
      kitchenEfficiency: this.calculateKitchenEfficiency(),
      customerSatisfactionImpact: this.predictSatisfactionImpact(order, newStatus),
      revenueImpact: this.calculateRevenueImpact(order, newStatus),
      staffWorkloadImpact: this.calculateWorkloadImpact(newStatus)
    }
  }
}
```

### 3. Counter Journey: Payment Processing (Target: <10 seconds)
```typescript
// ‚úÖ PAYMENT-OPTIMIZED: Multi-step payment with error handling
class PaymentWorkflowEngine {
  // Payment processing with comprehensive business validation
  async processPayment(paymentRequest: PaymentRequest): Promise<PaymentResult> {
    // 1. Pre-flight validation (instant)
    const validation = await this.validatePaymentBusiness(paymentRequest)
    if (!validation.isValid) {
      throw new PaymentValidationError(validation.errors)
    }
    
    // 2. Calculate final amounts with business rules
    const calculation = await this.calculatePaymentAmounts(paymentRequest)
    
    // 3. Process payment with error handling
    try {
      const result = await this.executePayment(calculation)
      
      // 4. Update business state
      await this.updateBusinessState(result)
      
      // 5. Generate receipt and analytics
      await this.generateReceiptAndAnalytics(result)
      
      return result
    } catch (error) {
      await this.handlePaymentError(error, paymentRequest)
      throw error
    }
  }

  // Business-aware payment validation
  private async validatePaymentBusiness(request: PaymentRequest): Promise<ValidationResult> {
    const order = await this.orderService.getOrder(request.order_id)
    const errors: string[] = []
    
    // Order state validation
    if (!['ready', 'served'].includes(order.status)) {
      errors.push('Order must be ready or served before payment')
    }
    
    // Amount validation with business rules
    const expectedTotal = await this.calculateOrderTotal(order)
    if (Math.abs(request.amount - expectedTotal) > 0.01) {
      errors.push(`Payment amount ${request.amount} does not match order total ${expectedTotal}`)
    }
    
    // Business hours and policies
    if (request.payment_method === 'check' && !this.acceptsChecks()) {
      errors.push('Check payments not accepted during this period')
    }
    
    // Tip validation for business rules
    if (request.tip_amount && request.tip_amount > expectedTotal * 0.3) {
      errors.push('Tip amount seems unusually high, please confirm')
    }
    
    return { isValid: errors.length === 0, errors }
  }

  // Advanced payment calculation with business intelligence
  private async calculatePaymentAmounts(request: PaymentRequest): Promise<PaymentCalculation> {
    const order = await this.orderService.getOrderWithItems(request.order_id)
    
    return {
      subtotal: this.calculateSubtotal(order.items),
      tax: this.calculateTax(order.items), // Business-specific tax rules
      discounts: await this.calculateDiscounts(order), // Loyalty, promotions
      serviceCharge: this.calculateServiceCharge(order), // Table service, large parties
      tip: request.tip_amount || 0,
      finalTotal: this.calculateFinalTotal(order, request),
      paymentBreakdown: this.generatePaymentBreakdown(request)
    }
  }
}
```

## üèóÔ∏è Tech Debt Prevention Patterns

### 1. Consistency Enforcement
```typescript
// ‚úÖ CONSISTENT: Standardized patterns across the system
namespace POSConsistency {
  // API Response consistency
  export interface StandardAPIResponse<T> {
    success: boolean
    message: string
    data?: T
    error?: string
    timestamp: string
    request_id: string // For debugging and tracing
  }

  // Error handling consistency
  export class BusinessError extends Error {
    code: string
    userMessage: string
    context: Record<string, any>
    
    constructor(code: string, message: string, userMessage: string, context?: Record<string, any>) {
      super(message)
      this.code = code
      this.userMessage = userMessage
      this.context = context || {}
    }
  }

  // State management consistency
  export interface BaseEntityState<T> {
    items: T[]
    loading: boolean
    error: string | null
    lastUpdated: Date
    optimisticUpdates: Map<string, T>
  }
}
```

### 2. DRY Principle Enforcement
```typescript
// ‚úÖ DRY: Reusable business logic components
class ReusableBusinessComponents {
  // Unified validation system
  static createValidator<T>(schema: ValidationSchema<T>) {
    return {
      validate: (data: T): ValidationResult => {
        const errors: string[] = []
        
        Object.entries(schema.rules).forEach(([field, rules]) => {
          const value = data[field]
          rules.forEach(rule => {
            if (!rule.check(value)) {
              errors.push(rule.message)
            }
          })
        })
        
        return { isValid: errors.length === 0, errors }
      }
    }
  }

  // Unified caching system
  static createCacheManager<T>(config: CacheConfig) {
    const cache = new Map<string, CacheEntry<T>>()
    
    return {
      get: async (key: string, fetcher: () => Promise<T>): Promise<T> => {
        const cached = cache.get(key)
        if (cached && cached.expiresAt > Date.now()) {
          return cached.data
        }
        
        const data = await fetcher()
        cache.set(key, {
          data,
          expiresAt: Date.now() + config.ttl,
          createdAt: Date.now()
        })
        
        return data
      },
      
      invalidate: (key: string) => cache.delete(key),
      clear: () => cache.clear()
    }
  }

  // Unified state management
  static createStateManager<T>(initialState: T) {
    const subscribers = new Set<(state: T) => void>()
    let currentState = { ...initialState }
    
    return {
      getState: () => currentState,
      setState: (updater: (state: T) => T) => {
        const newState = updater(currentState)
        currentState = newState
        subscribers.forEach(callback => callback(newState))
      },
      subscribe: (callback: (state: T) => void) => {
        subscribers.add(callback)
        return () => subscribers.delete(callback)
      }
    }
  }
}
```

## ‚ö° Performance-First Development Patterns

### 1. Database Performance Optimization
```go
// ‚úÖ PERFORMANCE: Intelligent query optimization with business understanding
type QueryOptimizer struct {
    db                 *sql.DB
    queryCache         *QueryCache
    performanceMetrics *PerformanceMetrics
}

// Business-aware query optimization
func (q *QueryOptimizer) GetOrdersOptimized(ctx context.Context, params OrderQueryParams) (*OrdersResult, error) {
    // 1. Query planning based on business patterns
    queryPlan := q.createQueryPlan(params)
    
    // 2. Use business-specific indexes
    query := `
        SELECT 
            o.id, o.order_number, o.status, o.created_at, o.total_amount,
            u.username, u.role,
            t.table_number, t.section,
            COUNT(oi.id) as item_count,
            -- Performance: Calculate totals in DB, not application
            SUM(oi.quantity * oi.price) as calculated_total
        FROM orders o
        -- Performance: Use covering indexes
        LEFT JOIN users u ON o.user_id = u.id  
        LEFT JOIN dining_tables t ON o.table_id = t.id
        LEFT JOIN order_items oi ON o.id = oi.order_id
        WHERE 1=1
    `
    
    args := []interface{}{}
    argIndex := 1
    
    // Business-aware filtering
    if params.Status != "" {
        query += fmt.Sprintf(" AND o.status = $%d", argIndex)
        args = append(args, params.Status)
        argIndex++
    }
    
    if params.DateRange.IsValid() {
        query += fmt.Sprintf(" AND o.created_at BETWEEN $%d AND $%d", argIndex, argIndex+1)
        args = append(args, params.DateRange.Start, params.DateRange.End)
        argIndex += 2
    }
    
    // Performance: Smart pagination with business context
    if params.UserRole == "kitchen" {
        // Kitchen sees only orders that need preparation
        query += " AND o.status IN ('pending', 'confirmed', 'preparing')"
        query += " ORDER BY o.priority DESC, o.created_at ASC" // Urgency first
    } else {
        query += " ORDER BY o.created_at DESC"
    }
    
    query += fmt.Sprintf(" GROUP BY o.id, u.username, u.role, t.table_number, t.section")
    query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIndex, argIndex+1)
    args = append(args, params.Limit, params.Offset)
    
    // Execute with performance monitoring
    start := time.Now()
    rows, err := q.db.QueryContext(ctx, query, args...)
    duration := time.Since(start)
    
    // Business intelligence: Track query performance
    q.performanceMetrics.RecordQuery("get_orders", duration, len(args))
    
    if duration > 100*time.Millisecond {
        log.Printf("SLOW QUERY WARNING: get_orders took %v", duration)
    }
    
    return q.processOrderResults(rows)
}
```

### 2. Frontend Performance with Business Intelligence
```typescript
// ‚úÖ PERFORMANCE: Intelligent component optimization with business understanding
class BusinessIntelligentComponents {
  // Smart memoization based on business context
  static createSmartMemo<T extends ComponentProps>(
    Component: React.FC<T>,
    businessContext: BusinessContext
  ): React.FC<T> {
    return React.memo(Component, (prevProps, nextProps) => {
      // Business-aware comparison
      if (businessContext.isHighFrequencyUpdate) {
        // Kitchen orders update frequently - check only critical props
        return (
          prevProps.id === nextProps.id &&
          prevProps.status === nextProps.status &&
          prevProps.priority === nextProps.priority
        )
      } else {
        // Admin data changes less frequently - deep comparison ok
        return isEqual(prevProps, nextProps)
      }
    })
  }

  // Intelligent data prefetching based on user journey
  static createDataPrefetcher(userRole: UserRole) {
    const prefetchStrategy = {
      admin: {
        prefetchOnIdle: ['reports', 'analytics', 'staff-performance'],
        preloadCritical: ['active-orders', 'system-status'],
        cacheStrategy: 'aggressive' // Admin needs comprehensive data
      },
      server: {
        prefetchOnIdle: ['menu-items', 'table-status'],
        preloadCritical: ['available-tables', 'active-categories'],
        cacheStrategy: 'moderate' // Balance speed vs memory
      },
      kitchen: {
        prefetchOnIdle: [],
        preloadCritical: ['pending-orders', 'preparation-queue'],
        cacheStrategy: 'minimal' // Real-time data, minimal cache
      }
    }

    return prefetchStrategy[userRole]
  }
}
```

## üß™ QA Integration & Error Prevention

### 1. Business Logic Testing Patterns
```typescript
// ‚úÖ QA: Business logic testing with domain understanding
describe('POS Business Logic Tests', () => {
  describe('Order Creation Business Rules', () => {
    it('should prevent order creation outside business hours', async () => {
      // Given: Restaurant is closed
      const mockTime = new Date('2024-01-01T02:00:00') // 2 AM
      jest.setSystemTime(mockTime)
      
      // When: Server attempts to create order
      const orderRequest = createMockOrderRequest({
        order_type: 'dine_in',
        items: [{ product_id: 'burger-1', quantity: 1 }]
      })
      
      // Then: Should reject with business rule error
      await expect(orderService.createOrder(orderRequest))
        .rejects
        .toThrow(BusinessRuleError)
        .toMatchBusinessRule('OUTSIDE_BUSINESS_HOURS')
    })

    it('should calculate complex pricing with discounts and tax', async () => {
      // Given: Order with loyalty discount and special tax rules
      const customer = createMockCustomer({ loyaltyTier: 'gold' })
      const orderItems = [
        { product_id: 'burger-1', quantity: 2, price: 12.99 },
        { product_id: 'drink-1', quantity: 2, price: 3.99 }
      ]
      
      // When: Calculate final pricing
      const pricing = await pricingService.calculateOrderTotal({
        items: orderItems,
        customer,
        appliedPromotions: ['GOLD_10_PERCENT']
      })
      
      // Then: Should apply business rules correctly
      expect(pricing).toMatchBusinessCalculation({
        subtotal: 33.96,
        discount: 3.40, // 10% gold discount
        tax: 2.75, // 9% tax after discount
        total: 33.31
      })
    })
  })

  describe('Kitchen Workflow Business Rules', () => {
    it('should prioritize orders based on business intelligence', async () => {
      // Given: Multiple orders with different priorities
      const orders = [
        createMockOrder({ table_id: 'vip-1', wait_time: 15, complexity: 'high' }),
        createMockOrder({ table_id: 'regular-1', wait_time: 25, complexity: 'low' }),
        createMockOrder({ table_id: 'regular-2', wait_time: 10, complexity: 'medium' })
      ]
      
      // When: Kitchen optimizes queue
      const optimizedQueue = await kitchenService.optimizeOrderQueue(orders)
      
      // Then: Should prioritize based on business rules
      expect(optimizedQueue).toMatchBusinessPriority([
        'vip-1', // VIP table trumps wait time
        'regular-2', // Shorter wait time + medium complexity
        'regular-1' // Longest wait but easiest to complete
      ])
    })
  })
})

// Custom Jest matchers for business logic
expect.extend({
  toMatchBusinessRule(received: Error, expectedRule: string) {
    const pass = received instanceof BusinessRuleError && received.code === expectedRule
    return {
      message: () => `Expected business rule ${expectedRule}, got ${received.constructor.name}`,
      pass
    }
  },
  
  toMatchBusinessCalculation(received: PricingResult, expected: PricingExpectation) {
    const toleranceChecks = Object.entries(expected).every(([key, value]) => {
      const actual = received[key]
      return Math.abs(actual - value) < 0.01 // Penny tolerance for financial calculations
    })
    
    return {
      message: () => `Business calculation mismatch: expected ${JSON.stringify(expected)}, got ${JSON.stringify(received)}`,
      pass: toleranceChecks
    }
  }
})
```

### 2. Error Prevention with Business Context
```typescript
// ‚úÖ ERROR PREVENTION: Comprehensive error handling with business intelligence
class BusinessErrorPrevention {
  // Intelligent error recovery based on business impact
  static createErrorRecoveryManager(businessContext: BusinessContext) {
    return {
      handleOrderError: async (error: Error, orderContext: OrderContext) => {
        const businessImpact = this.assessBusinessImpact(error, orderContext)
        
        switch (businessImpact.severity) {
          case 'critical':
            // Revenue-affecting errors - immediate escalation
            await this.notifyManagement(error, orderContext)
            await this.createEmergencyBackup()
            return this.initiateFailsafeMode(orderContext)
            
          case 'high':
            // Customer-affecting errors - graceful degradation
            await this.notifyStaff(error, orderContext)
            return this.provideFallbackService(orderContext)
            
          case 'medium':
            // Performance errors - log and continue
            this.logBusinessError(error, orderContext)
            return this.retryWithBackoff(orderContext)
            
          case 'low':
            // Minor errors - silent recovery
            return this.silentRecover(orderContext)
        }
      },
      
      assessBusinessImpact: (error: Error, context: OrderContext): BusinessImpactAssessment => {
        // Business intelligence for error severity
        const factors = {
          revenueImpact: this.calculateRevenueAtRisk(context),
          customerImpact: this.calculateCustomerExperienceImpact(context),
          operationalImpact: this.calculateOperationalDisruption(context),
          timeOfDay: this.getBusinessPeriodSeverity(),
          staffAvailability: this.getStaffAvailabilityFactor()
        }
        
        return this.computeBusinessSeverity(factors)
      }
    }
  }

  // Proactive error prevention
  static createPreventiveHealthChecks() {
    return {
      // Business-critical system health
      checkOrderSystemHealth: async (): Promise<HealthCheck> => {
        const checks = await Promise.all([
          this.checkDatabasePerformance(), // Order creation speed
          this.checkPaymentGateway(), // Payment processing
          this.checkKitchenConnectivity(), // Kitchen display updates
          this.checkInventorySync(), // Product availability
          this.checkTableManagement() // Table status accuracy
        ])
        
        return this.aggregateHealthStatus(checks)
      },
      
      // Predictive failure detection
      detectPotentialFailures: async (): Promise<PredictiveAlert[]> => {
        const alerts: PredictiveAlert[] = []
        
        // Database performance degradation
        if (await this.isDatabaseSlowing()) {
          alerts.push({
            type: 'database_performance',
            severity: 'warning',
            businessImpact: 'Order creation may slow down',
            recommendedAction: 'Consider scaling database resources'
          })
        }
        
        // Kitchen queue overload
        const kitchenLoad = await this.getKitchenQueueLoad()
        if (kitchenLoad > 0.8) {
          alerts.push({
            type: 'kitchen_overload',
            severity: 'high',
            businessImpact: 'Customer wait times will increase',
            recommendedAction: 'Alert kitchen manager to optimize workflow'
          })
        }
        
        return alerts
      }
    }
  }
}
```

## üìä Business Intelligence Integration

### 1. Performance Monitoring with Business Context
```typescript
// ‚úÖ BUSINESS INTELLIGENCE: Performance monitoring with business insights
class BusinessIntelligenceMonitoring {
  // Revenue-aware performance tracking
  static trackBusinessMetrics(operation: string, duration: number, businessContext: BusinessContext): void {
    const metrics = {
      operation,
      duration,
      timestamp: Date.now(),
      
      // Business context
      revenueImpact: businessContext.calculateRevenueImpact(duration),
      customerImpact: businessContext.calculateCustomerImpact(duration),
      operationalEfficiency: businessContext.calculateEfficiency(duration),
      
      // Performance classification
      performanceGrade: this.classifyPerformance(operation, duration),
      businessCriticality: this.assessBusinessCriticality(operation, businessContext)
    }
    
    // Real-time business alerts
    if (metrics.revenueImpact > 100) { // $100+ revenue at risk
      this.sendBusinessAlert(`High revenue impact detected: ${operation} took ${duration}ms`)
    }
    
    // Performance optimization recommendations
    if (metrics.performanceGrade === 'poor') {
      this.generateOptimizationRecommendation(metrics)
    }
  }

  // Business-intelligent caching strategy
  static createBusinessCache<T>() {
    return {
      // Cache strategy based on business value
      set: (key: string, value: T, businessContext: BusinessContext) => {
        const ttl = this.calculateOptimalTTL(key, businessContext)
        const priority = this.calculateCachePriority(key, businessContext)
        
        return this.cache.set(key, value, { ttl, priority })
      },
      
      // Intelligent cache invalidation
      invalidateByBusinessEvent: (event: BusinessEvent) => {
        const affectedKeys = this.getAffectedCacheKeys(event)
        affectedKeys.forEach(key => this.cache.invalidate(key))
      }
    }
  }
}
```

This comprehensive business logic pattern ensures your POS system truly understands the restaurant domain, optimizes for real business outcomes, prevents technical debt, and maintains the highest quality standards. The patterns are designed to work together to create a cohesive, high-performance system that scales with your business needs.

<function_calls>
<invoke name="todo_write">
<parameter name="merge">true