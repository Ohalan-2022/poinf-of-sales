---
description: Tech debt prevention patterns with consistency enforcement, code quality gates, and architectural governance
---

# üèóÔ∏è Tech Debt Prevention & Code Quality Governance

## üéØ Zero Tech Debt Philosophy

### Proactive Prevention Strategy
```typescript
// ‚úÖ TECH DEBT PREVENTION: Systematic approach to code quality
namespace TechDebtPrevention {
  // Code quality metrics and thresholds
  interface QualityGates {
    code_coverage: { minimum: 85, target: 90 }
    complexity_score: { maximum: 10, target: 7 }
    duplication: { maximum: 3, target: 1 }
    performance: { api_response: '< 200ms', ui_render: '< 100ms' }
    security: { vulnerabilities: 0, code_quality: 'A' }
  }

  // Automated quality enforcement
  class QualityEnforcer {
    static enforcePreCommitQuality(): PreCommitHook {
      return {
        // Code format and style
        prettier_format: true,
        eslint_validation: true,
        typescript_strict_check: true,
        
        // Business logic validation
        business_rule_consistency: true,
        api_contract_validation: true,
        database_migration_safety: true,
        
        // Performance validation
        bundle_size_check: true,
        query_performance_validation: true,
        memory_leak_detection: true
      }
    }
  }
}
```

## üîí Consistency Enforcement Patterns

### 1. Architectural Consistency
```typescript
// ‚úÖ CONSISTENCY: Standardized architectural patterns
class ArchitecturalConsistency {
  // Enforce consistent API patterns
  static createAPIEndpoint<TRequest, TResponse>(
    config: APIEndpointConfig<TRequest, TResponse>
  ): StandardAPIEndpoint<TRequest, TResponse> {
    return {
      // Standardized request validation
      validateRequest: (request: TRequest): ValidationResult => {
        const validator = this.createValidator(config.validation_schema)
        return validator.validate(request)
      },

      // Standardized business logic execution
      executeBusinessLogic: async (request: TRequest): Promise<TResponse> => {
        // Consistent error handling
        try {
          // Standardized logging
          Logger.info(`Executing ${config.endpoint_name}`, { request })
          
          // Business logic with consistent patterns
          const result = await config.business_logic(request)
          
          // Standardized success response
          return {
            success: true,
            message: config.success_message,
            data: result,
            timestamp: new Date().toISOString(),
            request_id: generateRequestId()
          }
        } catch (error) {
          // Standardized error handling
          return this.handleStandardError(error, config.endpoint_name)
        }
      },

      // Standardized response formatting
      formatResponse: (response: TResponse): StandardAPIResponse<TResponse> => {
        return {
          ...response,
          version: config.api_version,
          performance_metrics: this.getPerformanceMetrics()
        }
      }
    }
  }

  // Enforce consistent component patterns
  static createBusinessComponent<TProps>(
    config: ComponentConfig<TProps>
  ): React.FC<TProps> {
    return React.memo((props: TProps) => {
      // Standardized error boundary
      return (
        <ErrorBoundary fallback={config.error_fallback}>
          {/* Standardized loading states */}
          <Suspense fallback={config.loading_fallback}>
            {/* Standardized accessibility */}
            <div 
              role={config.accessibility.role}
              aria-label={config.accessibility.label}
              className={cn(config.base_classes, props.className)}
            >
              {/* Component content with consistent patterns */}
              {config.render(props)}
            </div>
          </Suspense>
        </ErrorBoundary>
      )
    }, config.memo_comparison || shallowEqual)
  }

  // Database query consistency
  static createDatabaseQuery<TParams, TResult>(
    config: QueryConfig<TParams, TResult>
  ): DatabaseQuery<TParams, TResult> {
    return {
      execute: async (params: TParams): Promise<TResult> => {
        // Standardized query performance monitoring
        const startTime = performance.now()
        
        try {
          // Standardized parameter validation
          this.validateQueryParams(params, config.param_schema)
          
          // Standardized query execution
          const result = await this.executeQuery(config.query, params)
          
          // Standardized performance logging
          const duration = performance.now() - startTime
          this.logQueryPerformance(config.name, duration, params)
          
          return result
        } catch (error) {
          // Standardized error handling
          this.handleQueryError(error, config.name, params)
          throw error
        }
      }
    }
  }
}
```

### 2. Code Pattern Enforcement
```typescript
// ‚úÖ PATTERN ENFORCEMENT: Consistent code patterns across the system
class CodePatternEnforcement {
  // Standardized hook patterns
  static createBusinessHook<TData, TError = Error>(
    config: BusinessHookConfig<TData, TError>
  ): BusinessHook<TData, TError> {
    return function useBusinessData() {
      // Consistent state management
      const [state, setState] = useState<BusinessHookState<TData, TError>>({
        data: null,
        loading: false,
        error: null,
        lastUpdated: null
      })

      // Consistent data fetching
      const fetchData = useCallback(async () => {
        setState(prev => ({ ...prev, loading: true, error: null }))
        
        try {
          const data = await config.fetcher()
          setState({
            data,
            loading: false,
            error: null,
            lastUpdated: new Date()
          })
        } catch (error) {
          setState(prev => ({
            ...prev,
            loading: false,
            error: error as TError
          }))
        }
      }, [config.dependencies])

      // Consistent lifecycle management
      useEffect(() => {
        if (config.auto_fetch) {
          fetchData()
        }
      }, [fetchData])

      // Consistent return interface
      return {
        ...state,
        refetch: fetchData,
        reset: () => setState({
          data: null,
          loading: false,
          error: null,
          lastUpdated: null
        })
      }
    }
  }

  // Standardized service patterns
  static createBusinessService<TConfig>(
    config: BusinessServiceConfig<TConfig>
  ): BusinessService<TConfig> {
    return {
      // Consistent initialization
      initialize: async (): Promise<void> => {
        Logger.info(`Initializing ${config.service_name}`)
        await config.initialize?.()
      },

      // Consistent method patterns
      ...Object.entries(config.methods).reduce((service, [methodName, methodConfig]) => {
        service[methodName] = async (...args: any[]): Promise<any> => {
          // Consistent logging
          Logger.debug(`${config.service_name}.${methodName}`, { args })
          
          // Consistent validation
          if (methodConfig.validation) {
            const validation = methodConfig.validation(...args)
            if (!validation.isValid) {
              throw new ValidationError(validation.errors)
            }
          }

          // Consistent caching
          if (methodConfig.cache) {
            const cacheKey = methodConfig.cache.keyGenerator(...args)
            const cached = await this.cache.get(cacheKey)
            if (cached) return cached
          }

          // Execute business logic
          const result = await methodConfig.implementation(...args)

          // Consistent caching
          if (methodConfig.cache) {
            const cacheKey = methodConfig.cache.keyGenerator(...args)
            await this.cache.set(cacheKey, result, methodConfig.cache.ttl)
          }

          return result
        }
        return service
      }, {} as any)
    }
  }
}
```

## üîÑ DRY Principle Implementation

### 1. Reusable Business Logic Components
```typescript
// ‚úÖ DRY: Centralized business logic to eliminate duplication
namespace ReusableBusinessLogic {
  // Unified validation system
  export class ValidationEngine {
    private static validators = new Map<string, Validator<any>>()

    static registerValidator<T>(name: string, validator: Validator<T>): void {
      this.validators.set(name, validator)
    }

    static createCompositeValidator<T>(
      validatorNames: string[],
      customValidations?: Validation<T>[]
    ): Validator<T> {
      return {
        validate: (data: T): ValidationResult => {
          const errors: string[] = []
          
          // Apply registered validators
          validatorNames.forEach(name => {
            const validator = this.validators.get(name)
            if (validator) {
              const result = validator.validate(data)
              if (!result.isValid) {
                errors.push(...result.errors)
              }
            }
          })

          // Apply custom validations
          customValidations?.forEach(validation => {
            if (!validation.check(data)) {
              errors.push(validation.message)
            }
          })

          return {
            isValid: errors.length === 0,
            errors
          }
        }
      }
    }
  }

  // Unified caching system
  export class UnifiedCache {
    private static cache = new Map<string, CacheEntry<any>>()
    private static strategies = new Map<string, CacheStrategy>()

    static registerStrategy(name: string, strategy: CacheStrategy): void {
      this.strategies.set(name, strategy)
    }

    static async get<T>(
      key: string,
      fetcher: () => Promise<T>,
      strategyName: string = 'default'
    ): Promise<T> {
      const strategy = this.strategies.get(strategyName)
      if (!strategy) {
        throw new Error(`Cache strategy '${strategyName}' not found`)
      }

      const cached = this.cache.get(key)
      if (cached && cached.expiresAt > Date.now()) {
        return cached.data as T
      }

      const data = await fetcher()
      this.cache.set(key, {
        data,
        expiresAt: Date.now() + strategy.ttl,
        createdAt: Date.now(),
        accessCount: 1
      })

      return data
    }

    static invalidatePattern(pattern: string): void {
      const regex = new RegExp(pattern)
      Array.from(this.cache.keys())
        .filter(key => regex.test(key))
        .forEach(key => this.cache.delete(key))
    }
  }

  // Unified state management
  export class BusinessStateManager<T> {
    private state: T
    private subscribers = new Set<StateChangeListener<T>>()
    private middleware: StateMiddleware<T>[] = []

    constructor(initialState: T) {
      this.state = { ...initialState }
    }

    getState(): T {
      return { ...this.state }
    }

    setState(updater: StateUpdater<T>): void {
      const previousState = { ...this.state }
      const newState = typeof updater === 'function' 
        ? updater(previousState) 
        : { ...previousState, ...updater }

      // Apply middleware
      const processedState = this.middleware.reduce(
        (state, middleware) => middleware.process(state, previousState),
        newState
      )

      this.state = processedState
      
      // Notify subscribers
      this.subscribers.forEach(listener => 
        listener(processedState, previousState)
      )
    }

    subscribe(listener: StateChangeListener<T>): () => void {
      this.subscribers.add(listener)
      return () => this.subscribers.delete(listener)
    }

    addMiddleware(middleware: StateMiddleware<T>): void {
      this.middleware.push(middleware)
    }
  }

  // Unified HTTP client
  export class BusinessHTTPClient {
    private static instance: BusinessHTTPClient
    private interceptors: HTTPInterceptor[] = []
    private retryPolicies = new Map<string, RetryPolicy>()

    static getInstance(): BusinessHTTPClient {
      if (!this.instance) {
        this.instance = new BusinessHTTPClient()
      }
      return this.instance
    }

    async request<TResponse>(config: HTTPRequestConfig): Promise<TResponse> {
      let processedConfig = { ...config }
      
      // Apply request interceptors
      for (const interceptor of this.interceptors) {
        if (interceptor.request) {
          processedConfig = await interceptor.request(processedConfig)
        }
      }

      // Execute request with retry policy
      const retryPolicy = this.retryPolicies.get(config.endpoint) || DEFAULT_RETRY_POLICY
      return this.executeWithRetry(processedConfig, retryPolicy)
    }

    private async executeWithRetry<TResponse>(
      config: HTTPRequestConfig,
      retryPolicy: RetryPolicy
    ): Promise<TResponse> {
      let lastError: Error
      
      for (let attempt = 0; attempt <= retryPolicy.maxRetries; attempt++) {
        try {
          const response = await this.executeRequest<TResponse>(config)
          
          // Apply response interceptors
          let processedResponse = response
          for (const interceptor of this.interceptors) {
            if (interceptor.response) {
              processedResponse = await interceptor.response(processedResponse)
            }
          }
          
          return processedResponse
        } catch (error) {
          lastError = error as Error
          
          if (attempt < retryPolicy.maxRetries && retryPolicy.shouldRetry(error)) {
            await this.delay(retryPolicy.calculateDelay(attempt))
            continue
          }
          
          break
        }
      }
      
      throw lastError!
    }
  }
}
```

### 2. Shared Component Library
```typescript
// ‚úÖ DRY: Reusable UI components with consistent behavior
namespace SharedComponentLibrary {
  // Base form component with consistent validation and submission
  export const BusinessForm = <TFormData extends Record<string, any>>({
    schema,
    onSubmit,
    loading,
    children
  }: BusinessFormProps<TFormData>) => {
    const form = useForm<TFormData>({
      resolver: zodResolver(schema),
      mode: 'onChange' // Consistent validation timing
    })

    const handleSubmit = form.handleSubmit(async (data) => {
      try {
        await onSubmit(data)
      } catch (error) {
        // Consistent error handling
        if (error instanceof ValidationError) {
          error.fieldErrors.forEach(({ field, message }) => {
            form.setError(field as Path<TFormData>, { message })
          })
        } else {
          // Global form error
          form.setError('root', { 
            message: error instanceof Error ? error.message : 'An error occurred'
          })
        }
      }
    })

    return (
      <Form {...form}>
        <form onSubmit={handleSubmit} className="space-y-6">
          {children}
          
          {/* Consistent form actions */}
          <FormActions>
            <Button type="submit" disabled={loading}>
              {loading ? <LoadingSpinner size="sm" /> : 'Submit'}
            </Button>
          </FormActions>
        </form>
      </Form>
    )
  }

  // Reusable data table with consistent features
  export const BusinessDataTable = <TData extends Record<string, any>>({
    data,
    columns,
    loading,
    pagination,
    sorting,
    filtering
  }: BusinessDataTableProps<TData>) => {
    // Consistent table state management
    const table = useReactTable({
      data: data || [],
      columns,
      getCoreRowModel: getCoreRowModel(),
      getSortedRowModel: getSortedRowModel(),
      getFilteredRowModel: getFilteredRowModel(),
      getPaginationRowModel: getPaginationRowModel(),
      
      // Consistent default configurations
      initialState: {
        pagination: { pageSize: 20 },
        sorting: [],
        columnVisibility: {}
      }
    })

    return (
      <div className="space-y-4">
        {/* Consistent table toolbar */}
        <DataTableToolbar table={table} filtering={filtering} />
        
        {/* Consistent table structure */}
        <div className="rounded-md border">
          <Table>
            <TableHeader>
              {table.getHeaderGroups().map(headerGroup => (
                <TableRow key={headerGroup.id}>
                  {headerGroup.headers.map(header => (
                    <TableHead key={header.id}>
                      {/* Consistent sorting indicators */}
                      <DataTableColumnHeader header={header} />
                    </TableHead>
                  ))}
                </TableRow>
              ))}
            </TableHeader>
            
            <TableBody>
              {loading ? (
                <DataTableSkeleton columnCount={columns.length} />
              ) : table.getRowModel().rows?.length ? (
                table.getRowModel().rows.map(row => (
                  <TableRow key={row.id}>
                    {row.getVisibleCells().map(cell => (
                      <TableCell key={cell.id}>
                        {flexRender(cell.column.columnDef.cell, cell.getContext())}
                      </TableCell>
                    ))}
                  </TableRow>
                ))
              ) : (
                <DataTableEmpty columnCount={columns.length} />
              )}
            </TableBody>
          </Table>
        </div>
        
        {/* Consistent pagination */}
        <DataTablePagination table={table} />
      </div>
    )
  }

  // Reusable business card with consistent layout
  export const BusinessCard = ({
    title,
    description,
    actions,
    status,
    metadata,
    children
  }: BusinessCardProps) => {
    return (
      <Card className="h-full">
        <CardHeader className="pb-3">
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <CardTitle className="text-base">{title}</CardTitle>
              {description && (
                <CardDescription>{description}</CardDescription>
              )}
            </div>
            
            {status && (
              <Badge variant={getStatusVariant(status)}>
                {status}
              </Badge>
            )}
          </div>
        </CardHeader>
        
        <CardContent className="pb-3">
          {children}
          
          {metadata && (
            <div className="mt-4 text-sm text-muted-foreground">
              {Object.entries(metadata).map(([key, value]) => (
                <div key={key} className="flex justify-between">
                  <span>{key}:</span>
                  <span>{value}</span>
                </div>
              ))}
            </div>
          )}
        </CardContent>
        
        {actions && (
          <CardFooter className="pt-3">
            <div className="flex gap-2 w-full">
              {actions.map((action, index) => (
                <Button
                  key={index}
                  variant={action.variant || 'outline'}
                  size="sm"
                  onClick={action.onClick}
                  disabled={action.disabled}
                  className={action.className}
                >
                  {action.label}
                </Button>
              ))}
            </div>
          </CardFooter>
        )}
      </Card>
    )
  }
}
```

## üõ°Ô∏è Quality Gates & Automation

### 1. Automated Code Quality Checks
```typescript
// ‚úÖ QUALITY GATES: Automated enforcement of quality standards
class QualityGateEnforcement {
  // Pre-commit quality checks
  static createPreCommitPipeline(): QualityPipeline {
    return {
      stages: [
        {
          name: 'Format Check',
          check: async (files: string[]) => {
            const results = await Promise.all([
              this.checkPrettierFormatting(files),
              this.checkESLintRules(files),
              this.checkTypeScriptCompilation(files)
            ])
            
            return {
              passed: results.every(r => r.passed),
              errors: results.flatMap(r => r.errors),
              autoFixAvailable: results.some(r => r.autoFixAvailable)
            }
          }
        },
        
        {
          name: 'Business Logic Validation',
          check: async (files: string[]) => {
            return {
              passed: await this.validateBusinessRuleConsistency(files),
              errors: await this.getBusinessRuleViolations(files),
              autoFixAvailable: false
            }
          }
        },
        
        {
          name: 'Performance Validation',
          check: async (files: string[]) => {
            const results = await Promise.all([
              this.checkBundleSize(files),
              this.validateQueryPerformance(files),
              this.checkMemoryLeaks(files)
            ])
            
            return {
              passed: results.every(r => r.passed),
              errors: results.flatMap(r => r.errors),
              warnings: results.flatMap(r => r.warnings || [])
            }
          }
        }
      ],
      
      onFailure: (stage: QualityStage, errors: QualityError[]) => {
        throw new QualityGateError(
          `Quality gate failed at stage: ${stage.name}`,
          errors
        )
      }
    }
  }

  // Code review automation
  static createCodeReviewAssistant(): CodeReviewAssistant {
    return {
      // Automated pattern detection
      detectPatternViolations: (diff: GitDiff): PatternViolation[] => {
        const violations: PatternViolation[] = []
        
        // Check for DRY violations
        const duplicateCode = this.detectDuplicateCode(diff)
        if (duplicateCode.length > 0) {
          violations.push({
            type: 'DRY_VIOLATION',
            severity: 'high',
            message: 'Duplicate code detected',
            suggestions: duplicateCode.map(d => d.refactoringSuggestion)
          })
        }
        
        // Check for inconsistent patterns
        const inconsistentPatterns = this.detectInconsistentPatterns(diff)
        violations.push(...inconsistentPatterns)
        
        return violations
      },

      // Automated test coverage analysis
      analyzeTes tCoverage: (diff: GitDiff): TestCoverageAnalysis => {
        return {
          coverage_percentage: this.calculateCoverageForDiff(diff),
          missing_tests: this.findUntested Code(diff),
          test_quality_score: this.assessTestQuality(diff),
          recommendations: this.generateTestRecommendations(diff)
        }
      },

      // Performance impact analysis
      analyzePerformanceImpact: (diff: GitDiff): PerformanceAnalysis => {
        return {
          bundle_size_impact: this.calculateBundleSizeChange(diff),
          query_performance_impact: this.analyzeQueryChanges(diff),
          memory_impact: this.analyzeMemoryImpact(diff),
          recommendations: this.generatePerformanceRecommendations(diff)
        }
      }
    }
  }
}
```

### 2. Continuous Quality Monitoring
```typescript
// ‚úÖ MONITORING: Continuous quality and tech debt monitoring
class ContinuousQualityMonitoring {
  // Technical debt detection
  static createTechDebtMonitor(): TechDebtMonitor {
    return {
      // Code complexity monitoring
      monitorComplexity: async (): Promise<ComplexityReport> => {
        const files = await this.getAllSourceFiles()
        const complexityResults = await Promise.all(
          files.map(file => this.analyzeFileComplexity(file))
        )
        
        return {
          overall_score: this.calculateOverallComplexityScore(complexityResults),
          high_complexity_files: complexityResults
            .filter(r => r.complexity > COMPLEXITY_THRESHOLD)
            .sort((a, b) => b.complexity - a.complexity),
          trending_complexity: this.calculateComplexityTrend(complexityResults),
          refactoring_candidates: this.identifyRefactoringCandidates(complexityResults)
        }
      },

      // Dependency analysis
      monitorDependencies: async (): Promise<DependencyReport> => {
        const dependencies = await this.analyzeDependencies()
        
        return {
          outdated_packages: dependencies.outdated,
          security_vulnerabilities: dependencies.vulnerabilities,
          unused_dependencies: dependencies.unused,
          circular_dependencies: dependencies.circular,
          upgrade_recommendations: this.generateUpgradeRecommendations(dependencies)
        }
      },

      // Performance regression detection
      monitorPerformanceRegressions: async (): Promise<PerformanceReport> => {
        const currentMetrics = await this.gatherPerformanceMetrics()
        const historicalMetrics = await this.getHistoricalMetrics()
        
        return {
          regressions: this.detectRegressions(currentMetrics, historicalMetrics),
          improvements: this.detectImprovements(currentMetrics, historicalMetrics),
          trending_metrics: this.calculateTrends(currentMetrics, historicalMetrics),
          optimization_opportunities: this.identifyOptimizationOpportunities(currentMetrics)
        }
      }
    }
  }

  // Automated refactoring suggestions
  static createRefactoringSuggestionEngine(): RefactoringSuggestionEngine {
    return {
      // Extract common patterns
      suggestPatternExtractions: (codebase: Codebase): PatternExtractionSuggestion[] => {
        const duplicatePatterns = this.findDuplicatePatterns(codebase)
        
        return duplicatePatterns.map(pattern => ({
          pattern_description: pattern.description,
          occurrences: pattern.locations,
          suggested_abstraction: pattern.suggestedAbstraction,
          estimated_impact: {
            lines_reduced: pattern.duplicateLines,
            maintainability_improvement: pattern.maintainabilityScore,
            test_coverage_impact: pattern.testCoverageChange
          }
        }))
      },

      // Component optimization suggestions
      suggestComponentOptimizations: (components: ComponentAnalysis[]): ComponentOptimization[] => {
        return components
          .filter(c => c.needsOptimization)
          .map(component => ({
            component_name: component.name,
            optimization_type: component.suggestedOptimization,
            current_issues: component.issues,
            suggested_solution: component.solution,
            implementation_effort: component.estimatedEffort
          }))
      },

      // Database optimization suggestions
      suggestDatabaseOptimizations: (queries: QueryAnalysis[]): DatabaseOptimization[] => {
        return queries
          .filter(q => q.performance_issues.length > 0)
          .map(query => ({
            query_identifier: query.id,
            performance_issues: query.performance_issues,
            suggested_indexes: query.suggestedIndexes,
            query_rewrite_suggestions: query.rewriteSuggestions,
            estimated_improvement: query.estimatedImprovement
          }))
      }
    }
  }
}
```

This comprehensive tech debt prevention system ensures that code quality remains high, patterns stay consistent, and the system continues to evolve without accumulating technical debt. The automated checks and monitoring provide continuous feedback to maintain the highest standards of code quality and architectural integrity.

<function_calls>
<invoke name="todo_write">
<parameter name="merge">true