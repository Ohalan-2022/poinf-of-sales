---
description: Security best practices and guidelines for POS System development
---

# Security Guidelines & Best Practices

## Authentication & Authorization

### JWT Token Security
Follow security patterns from [middleware/auth.go](mdc:backend/internal/middleware/auth.go):

### Token Management
```go
// Use strong, random JWT secrets (never hardcode)
var jwtSecret = []byte(os.Getenv("JWT_SECRET"))

// Set appropriate token expiration
expirationTime := time.Now().Add(24 * time.Hour)

// Include essential claims only
claims := &Claims{
    UserID:   user.ID,
    Username: user.Username, 
    Role:     user.Role,
    RegisteredClaims: jwt.RegisteredClaims{
        ExpiresAt: jwt.NewNumericDate(expirationTime),
        IssuedAt:  jwt.NewNumericDate(time.Now()),
        Issuer:    "pos-system",
    },
}
```

### Role-Based Access Control (RBAC)
Implement proper role checking:
```go
// Middleware for role-based access
admin.Use(middleware.RequireRoles([]string{"admin", "manager"}))
kitchen.Use(middleware.RequireRoles([]string{"kitchen", "admin", "manager"}))

// Always validate user context
userID, username, role, ok := middleware.GetUserFromContext(c)
if !ok {
    // Handle authentication failure
    return
}
```

## Input Validation & Sanitization

### SQL Injection Prevention
Always use parameterized queries as shown in [handlers/orders.go](mdc:backend/internal/handlers/orders.go):

```go
// Good: Parameterized query
query := `SELECT * FROM orders WHERE id = $1 AND user_id = $2`
err := h.db.QueryRow(query, orderID, userID).Scan(...)

// Bad: String concatenation (vulnerable)
// query := fmt.Sprintf("SELECT * FROM orders WHERE id = '%s'", orderID)
```

### Input Validation Patterns
```go
// Validate UUIDs
orderID, err := uuid.Parse(c.Param("id"))
if err != nil {
    c.JSON(http.StatusBadRequest, models.APIResponse{
        Success: false,
        Message: "Invalid order ID",
        Error:   stringPtr("invalid_uuid"),
    })
    return
}

// Validate enum values
validStatuses := []string{"pending", "confirmed", "preparing", "ready", "served", "completed", "cancelled"}
if !contains(validStatuses, req.Status) {
    c.JSON(http.StatusBadRequest, models.APIResponse{
        Success: false,
        Message: "Invalid order status",
        Error:   stringPtr("invalid_status"),
    })
    return
}

// Validate business rules
if req.Amount <= 0 {
    c.JSON(http.StatusBadRequest, models.APIResponse{
        Success: false,
        Message: "Payment amount must be greater than zero",
        Error:   stringPtr("invalid_amount"),
    })
    return
}
```

## Password Security

### Password Hashing
Use bcrypt for password hashing:
```go
import "golang.org/x/crypto/bcrypt"

// Hash password before storing
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// Verify password during login
func VerifyPassword(hashedPassword, password string) error {
    return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
```

### Password Policy
Implement strong password requirements:
- Minimum 8 characters
- Mix of uppercase, lowercase, numbers, special characters
- Prevent common passwords
- Enforce password rotation for admin accounts

## Data Protection

### Sensitive Data Handling
```go
type User struct {
    ID           uuid.UUID `json:"id"`
    Username     string    `json:"username"`
    Email        string    `json:"email"`
    PasswordHash string    `json:"-"` // Never expose in JSON responses
    // ... other fields
}
```

### Database Security
Follow patterns from [database/init/01_schema.sql](mdc:database/init/01_schema.sql):
- Use CHECK constraints for data validation
- Implement proper foreign key relationships
- Set appropriate column constraints (NOT NULL, UNIQUE)
- Use triggers for audit logging

### Audit Logging
Log security-relevant events:
```go
// Log authentication events
log.Printf("LOGIN_SUCCESS: user=%s, ip=%s", username, c.ClientIP())
log.Printf("LOGIN_FAILED: username=%s, ip=%s, reason=%s", username, c.ClientIP(), "invalid_credentials")

// Log privilege escalation attempts
log.Printf("ACCESS_DENIED: user=%s, role=%s, endpoint=%s", username, role, c.Request.URL.Path)

// Log sensitive operations
log.Printf("ORDER_CREATED: user=%s, order_id=%s, amount=%.2f", username, orderID, totalAmount)
log.Printf("PAYMENT_PROCESSED: user=%s, order_id=%s, method=%s, amount=%.2f", username, orderID, paymentMethod, amount)
```

## API Security

### CORS Configuration
Proper CORS setup in [main.go](mdc:backend/main.go):
```go
router.Use(cors.New(cors.Config{
    AllowOrigins:     []string{"http://localhost:3000", "https://yourdomain.com"}, // Specific origins only
    AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"},
    AllowHeaders:     []string{"Origin", "Content-Type", "Content-Length", "Accept-Encoding", "X-CSRF-Token", "Authorization"},
    AllowCredentials: true, // Only if needed for cookies
    MaxAge:           12 * time.Hour,
}))
```

### Rate Limiting
Implement rate limiting to prevent abuse:
```go
// Example rate limiting middleware
func RateLimitMiddleware(requestsPerMinute int) gin.HandlerFunc {
    return func(c *gin.Context) {
        // Implement rate limiting logic based on IP or user ID
        // Use tools like go-rate or implement custom solution
    }
}

// Apply to sensitive endpoints
protected.Use(RateLimitMiddleware(100)) // 100 requests per minute
```

### Request Size Limits
```go
// Limit request body size
router.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface{}) {
    if err, ok := recovered.(string); ok {
        c.Header("Content-Type", "application/json")
        c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": err})
    }
    c.AbortWithStatus(http.StatusInternalServerError)
}))

// Set max multipart form memory
router.MaxMultipartMemory = 8 << 20 // 8 MiB
```

## Frontend Security

### XSS Prevention
```typescript
// Sanitize user input before displaying
import DOMPurify from 'dompurify';

const sanitizedHTML = DOMPurify.sanitize(userInput);

// Use React's built-in XSS protection (JSX escaping)
const ProductCard = ({ product }) => (
  <div>
    <h3>{product.name}</h3> {/* Automatically escaped */}
    <p>{product.description}</p>
  </div>
);
```

### Secure API Communication
```typescript
// Always use HTTPS in production
const API_BASE_URL = process.env.NODE_ENV === 'production' 
  ? 'https://api.yourdomain.com' 
  : 'http://localhost:8080';

// Include authentication headers
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Token management
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('pos_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

### Content Security Policy (CSP)
Configure CSP in [nginx.conf](mdc:frontend/nginx.conf):
```nginx
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' http://localhost:8080;" always;
```

## Environment Security

### Environment Variables
Secure environment variable management:
```bash
# Use strong, unique secrets
JWT_SECRET=your-very-long-and-random-secret-key-here-minimum-256-bits

# Database credentials
DB_PASSWORD=complex-database-password-with-special-chars

# Never commit .env files with real secrets
echo ".env" >> .gitignore
echo ".env.production" >> .gitignore
```

### Docker Security
Follow security patterns from [Dockerfile](mdc:backend/Dockerfile):
```dockerfile
# Use specific versions, not 'latest'
FROM golang:1.21-alpine

# Create non-root user
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

# Copy files with appropriate ownership
COPY --from=builder --chown=appuser:appgroup /app/main .

# Switch to non-root user
USER appuser
```

## Database Security

### Connection Security
```go
// Use SSL connections in production
dsn := fmt.Sprintf(
    "host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
    config.Host, config.Port, config.User, config.Password, 
    config.DBName, config.SSLMode, // "require" in production
)
```

### Data Encryption
Consider encryption for sensitive fields:
```sql
-- Example of encrypted column (implement with application-level encryption)
CREATE TABLE sensitive_data (
    id UUID PRIMARY KEY,
    encrypted_ssn BYTEA, -- Application encrypts before storing
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

## Security Monitoring

### Log Analysis
Monitor security events:
```go
// Security event logging
type SecurityEvent struct {
    Timestamp time.Time `json:"timestamp"`
    Event     string    `json:"event"`
    UserID    string    `json:"user_id,omitempty"`
    IP        string    `json:"ip"`
    UserAgent string    `json:"user_agent"`
    Details   string    `json:"details"`
}

func LogSecurityEvent(event, userID, ip, userAgent, details string) {
    secEvent := SecurityEvent{
        Timestamp: time.Now(),
        Event:     event,
        UserID:    userID,
        IP:        ip,
        UserAgent: userAgent,
        Details:   details,
    }
    
    // Log to security monitoring system
    logJSON, _ := json.Marshal(secEvent)
    securityLogger.Info(string(logJSON))
}
```

### Alerting
Set up alerts for:
- Multiple failed login attempts
- Unusual API usage patterns
- Access to admin endpoints
- Database connection failures
- Unexpected error rates

## Compliance Considerations

### PCI DSS Compliance (if handling card data)
- Encrypt cardholder data at rest and in transit
- Implement strong access controls
- Regular security testing and vulnerability scans
- Maintain secure network architecture
- Monitor and test networks regularly

### Data Privacy
- Implement data minimization principles
- Provide data export/deletion capabilities
- Obtain proper consent for data collection
- Document data processing activities
- Implement privacy by design

## Security Testing

### Automated Security Testing
```bash
# Dependency vulnerability scanning
go list -json -m all | nancy sleuth

# Static code analysis
gosec ./...

# Container image scanning
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    aquasec/trivy image pos-backend:latest
```

### Manual Security Testing
- Penetration testing of API endpoints
- Authentication bypass attempts
- SQL injection testing
- XSS vulnerability testing
- CSRF protection validation

## Incident Response

### Security Incident Checklist
1. **Immediate Response**
   - Isolate affected systems
   - Preserve evidence
   - Assess scope of breach

2. **Investigation**
   - Analyze logs and audit trails
   - Identify attack vectors
   - Determine data accessed

3. **Recovery**
   - Patch vulnerabilities
   - Reset compromised credentials
   - Restore from clean backups if needed

4. **Communication**
   - Notify stakeholders
   - Document lessons learned
   - Update security procedures